(() => {
console.group('----------- 作用域 ------------')

    /* 
        一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独
        的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法
        行为，在不设置参数默认值时，是不会出现的。
    */
    const x = 1;

    function foo(x, y = x) {
        console.log(y)
    }

    foo(2)      // 2
    foo()       // undefined

    /* 
        上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个
        作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2
    */

    const a = 1;

    function tem(x = a) {
        let a = 2;
        console.log(x)
    }

    tem()       // 1

    /* 
        上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，
        变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部
        变量x影响不到默认值变量x。

    下面的代码将报错
        const x = 1;
        function foo(x = x) {
            ...
        }

        参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，
        这行代码会报错'x 未定义'。

        如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。
    */

    // 思考：
    var x1 = 1
    function bar1(x1, y = () => { x1 = 2}) {
        var x1 = 3;
        y();
        console.log(x1)
    }

    bar1()      // 3
    console.log('x1', x1)   // 1
    /* 
        上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x1，
        然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x1，指向同一个
        作用域的第一个参数x1。函数foo内部又声明了一个内部变量x1，该变量与第一个参数x1由
        于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x1和外部全局变量x1
        的值都没变。

        如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部
        的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。

        var x = 1;
        function foo(x, y = function() { x = 2; }) {
            x = 3;
            y();
            console.log(x);
        }

        foo() // 2
        x // 1
    */

console.groupEnd()
})()    