# JS 事件循环机制
***
## 1. 浏览器环境下JS引擎的事件循环机制
### 1.1 执行栈和事件队列
**执行栈**  

&emsp;&emsp;我们调用一个方法的时候，JS 会生成一个与该方法对应的执行环境 ( context ), 该执行环境中存放着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中的局部变量和该作用域的 this 对象。当多个方法被调用的时候，因为 JS 是单线程，一次只能执行一个方法，所以这些方法排在执行栈里等待执行。  
  
&emsp;&emsp;当一个脚本第一次运行的时候，js 解析代码后，将同步代码按照顺序添加到执行栈中，然后从头开始执行。  

&emsp;&emsp;如果当前执行的是一个方法，js会向执行栈当中添加这个方法的执行环境，然后在该执行环境下执行这个方法，当方法中的代码执行完毕并返回结果后，js会推出该执行环境并将其销毁，同时返回到此前的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。  
  
>一个方法执行时会向执行栈中添加该方法的执行环境，在这个执行方法中可以调用其他方法甚至是它自己，其结果无非就是在执行栈当中再添加一个执行环境。这个过程可以无限进行下去，除非发生栈溢出。  
  
**事件队列**  
&emsp;&emsp;以上说的都是同步代码的执行，那么异步代码时是如何处理的呢？js的一大特点时非阻塞，实现该特点的机制就是*事件队列（ Task Queue）*
  
&emsp;&emsp;js引擎遇到一个异步事件后并不会一直等待他的返回结果，而是先将这个异步事件挂起，并继续执行执行栈当中的任务。当一个异步事件返回结果后，js 会将这个事件加入到事件队列中。当执行栈中的所有代码执行完毕，主线程处于闲置状态，他会查找事件队列中是否存在任务。如果有任务，则会取出事件队列中排在第一位的事件，并把对应的回调函数放到执行栈当中，执行回调中的同步代码...如此反复形成事件循环（ Event Loop ）
   

### 1.2 微任务和宏任务
&emsp;异步任务之间也存在区别，它们的执行优先级存在区别；异步任务大体分为两类：微任务（micro task）和 宏任务 ( macro task )
>>以下属于宏任务：  
 &emsp;&emsp;&emsp;&emsp;`setTimeout()`  
&emsp;&emsp;&emsp;&emsp;`setInterval()`  
以下属于微任务：  
&emsp;&emsp;&emsp;&emsp;`new Promise()`  
&emsp;&emsp;&emsp;&emsp;`new MutationObserver()`    

>当前执行栈执行完毕后会立刻先执行所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。*同一次事件循环中，微任务永远排在宏任务之前执行。* 这样就可以解释下面的代码：
```javascript
    setTimeout(()=>{
        console.log(1)
    },100)
    new Promise(function(resolve,reject){
        console.log(2)
        resolve(3)
    }).then(function(val){
        console.log(val)
    })
    // 2 3 1
```     
   
***
## 2. node 环境下的事件循环机制

