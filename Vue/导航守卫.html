<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>导航守卫</title>
</head>
<body>
    <div id="app">
        <router-link to="/page1">page1</router-link>
        <router-link to="/page2">page2</router-link>
        <router-link to="/page1/001">page1/001</router-link>
        <router-link to="/page1/002">page1/002</router-link>
        <router-view></router-view>
    </div>
    <script src="./vue.min.js"></script>
    <script src="./vue-router.js"></script>
    <script>
    /* 
        全局钩子： router.beforeEach(), router.afterEach()
        路由级钩子： beforeEnter()
        组件级别钩子：beforeRouteEnter(),beforeRouteUpdate(),beforeRouteLeave()
    */

        const childOfPage1 = {
            template:`<h2>{{$route.params.id}}</h2>`,
            
            beforeRouteEnter (to, from, next) {
                console.log('组件级别child beforeRouteEnter to', to)
                // console.log('组件级别child beforeRouteEnter from', from)
                next()
            },

            beforeRouteUpdate(to,from,next){
                // 在当前路由改变，但是该组件被复用时调用
                // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
                // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
                // 可以访问组件实例 `this`
                console.log('组件级别钩子 组件复用 beforeRouteUpdate to', to)
                // console.log('组件级别钩子 组件复用 beforeRouteUpdate from', from)
                next()
            },
            beforeRouteLeave(to,from,next){
                    // 导航离开该组件的对应路由时调用
                    // 可以访问组件实例 `this`
                console.log('组件级别child  beforeRouteLeave to', to)
                // console.log('组件级别page1  beforeRouteLeave from', from)
                next()
            }  
        }

        const page1 = {
            template:`
            <div>
                <h1>page1</h1>
            </div>
            `,
            
            beforeRouteEnter (to, from, next) {

                 /*
                    在渲染该组件的对应路由被 confirm 前调用
                    不！能！获取组件实例 `this`
                    因为当守卫执行前，组件实例还没被创建
                    不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
                    next(vm => {
                        通过vm访问组件实例
                    }) 
                 */

                console.log('组件级别page1  beforeRouteEnter to', to)
                // console.log('组件级别page1  beforeRouteEnter from', from)
                next()

            },
            beforeRouteLeave(to,from,next){
                    // 导航离开该组件的对应路由时调用
                    // 可以访问组件实例 `this`
                console.log('组件级别page1  beforeRouteLeave to', to)
                // console.log('组件级别page1  beforeRouteLeave from', from)
                next()
            }  
        }
        const page2 = {
            template:`<h1>page2</h1>`,
            beforeRouteEnter (to, from, next) {
                console.log('组件级别page2  beforeRouteEnter to', to)
                // console.log('组件级别page1  beforeRouteEnter from', from)
                next()
            },
            beforeRouteLeave(to,from,next){
                
                console.log('组件级别page2  beforeRouteLeave to', to)
                // console.log('组件级别page1  beforeRouteLeave from', from)
                next()
            }
        }
        
        const router = new VueRouter({
            mode:'hash',
            routes:[{
                path:'/page1',
                component:page1,
                
                beforeEnter(to,from,next){
                    console.log('路由即将进入page1 路由级别钩子 beforeEnter to', to)
                    // console.log('路由即将进入page1 路由级别钩子 beforeEnter from', from)
                    next()
                }
            },{
                path:'/page2',
                component:page2,
                beforeEnter(to,from,next){
                    console.log('路由即将进入page2 路由级别钩子 beforeEnter to', to)
                    // console.log('路由即将进入page2 路由级别钩子 beforeEnter from', from)
                    next()
                }
            },{
                path:'/page1/:id',
                component:childOfPage1,
                beforeEnter(to,from,next){
                    console.log('动态路由 路由级别 beforeEnter to', to)
                    // console.log('路由即将进入page2 路由级别钩子 beforeEnter from', from)
                    next()
                }

            },{
                path:'/',
                redirect:'/page1'
            }]
        })

        // 1. 全局前置守卫
        router.beforeEach((to,from,next) => {
            console.log('全局前置to router.beforeEach', to)
            // console.log('全局前置from router.beforeEach', from)
            next()
        })

        // 2. 全局后置钩子 和守卫不同的是，这些钩子不会接受 next()函数也不会改变导航本身
        router.afterEach((to, from) => {
            // to and from are both route objects.
            console.log('全局后置钩子 router.afterEach to', to)
            // console.log('全局后置钩子 router.afterEach from', from)
        })
       
        new Vue({
            el:"#app",
            router,
        })

    /* 
            全局钩子： router.beforeEach(), router.afterEach()
            路由级钩子： beforeEnter()
            组件级别钩子：beforeRouteEnter(),beforeRouteUpdate(),beforeRouteLeave()

            完整的导航解析流程
                1. 导航被触发。
                2. 在失活的组件里调用离开守卫。
                3. 调用全局的 beforeEach 守卫。
                4. 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
                5. 在路由配置里调用 beforeEnter。
                6. 解析异步路由组件。
                7. 在被激活的组件里调用 beforeRouteEnter。
                8. 调用全局的 beforeResolve 守卫 (2.5+)。
                9. 导航被确认。
                10. 调用全局的 afterEach 钩子。
                11. 触发 DOM 更新。
                12. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。


        举例：路由从'/comp1' 到'comp2'
            1. 调用comp1 组件的 beforeRouteLeave()
            2. 调用全局的 router.beforeEach()
            3. 调用comp2 路由级别的 beforeEnter()
            4. 调用comp2 组件的 beforeRouterEnter()
            5. 调用全局的 router.afterEach()

        组件复用时，过程简化为：
            全局router.beforeEach() --> 组件 beforeRouteUpdate() --> 全局router.afterEach()
    */
    </script>
</body>
</html>